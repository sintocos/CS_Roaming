# Hello World

[英文版](<http://briansteffens.com/introduction-to-64-bit-assembly/01-hello-world/>)

为了与传统保持一致，我们编写的第一个程序只打印出“Hello，world！”然后退出。在大多数语言中，这是一行或两行的代码片段，但在汇编时就需要更多的行数。 不过不用担心，汇编语言在概念上和其他语言一样。 我们需要做的就是告诉操作系统要打印什么。

## 1 The program

首先打开你喜欢用的文本编辑器并输入以下程序：

```assembly
section .data

    message db "Hello, world!", 10

section .text

global _start
_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, message
    mov rdx, 14
    syscall
```

对于只向控制台输出"Hello,world!"的程序来说，这可能看起来非常复杂。然而，虽然它是冗长的，但实际上并不复杂：此代码只执行一个高级操作。 只是它恰好被分解成很多行。

在最高的层次上，该程序分成了两个部分: .data和.text。

- data部分包含程序将要使用的数据。程序运行时，该部分的内容将被加载到内存中，并可供代码使用。在这个例子中，data部分包含了一个名为"message"的文本字符串，该字符将被打印到控制台。
- text部分是代码所在的位置。 该部分是一个指令的列表，用来告诉计算机当程序运行时该做什么。 在这个例子中，text部分将告诉操作系统将字符串消息打印到控制台。

*注意：在汇编中，不能将文字字符串（如“Hello，world！”）直接混入到代码中。必须分别声明数据和作用于该数据的代码。*

从上到下分解上面的程序，一次只检查一行。

```assembly
section .data
```

这一行意味着数据部分的开始，数据部分可以为你的程序提供任何类型的静态数据。当程序运行时，操作系统将会把这些数据加载到内存中，并让代码可以读取或操作这些数据。

这些数据可以为任何东西：数字，数组，字符串，或其他任何东西。数据实际上只是一系列0和1，它的意义取决于代码如何解释。数据的含义或者数据的上下文来自于代码如何处理它。

```assembly
    message db "Hello, world!", 10
```

这一行声明了一个名为message的字符串，其值为“Hello，world！”。进一步分解这一行，可以看到它由以下几个部分组成：

- **message** - 这是稍后将在代码部分使用的名称，它用来引用已经被声明的数据。无论“message”出现在代码的哪个地方，计算机都会知道“message”实际上的意思是字符串“Hello, world!”。这个名字由程序员决定，它应该是描述性的，而且它所指向的内容应该是非常清楚的。

- **db** - 这是数据的类型。在本例中，"db"意味着声明的数据是一系列byte，即一系列字节。字节是一个8位的整数，每个整数的值都在0到255之中。我们使用字节是因为ASCII中的每个字符都可以用一个字节表示。这个字段还可以是其他东西，比如dw、dd和dq，它们都表示更大的整数。
- **"Hello, world!"** - 这是"message"所引用的数据内容，我们稍后将该其打印到控制台。每个字母、逗号、空格或感叹号都是一个字节。
- **, 10** - 这实际上是“Hello, world!”的延续，它是换行符的ASCII代码，将会被添加到字符串的末尾。它可以确保在打印完字符串后，控制台会移动到下一行而不是在这一行继续打印下一个提示符。如果你熟悉其他语言，那么可以将它看成是“Hello, world!\n”中的“\n”。

```assembly
section .text
```

这一行标志着*data*部分的结束和*text* 部分的开始，也就是代码所在的位置。data部分简单地声明了静态数据，供后续使用，而代码则是一系列指令，用来控制计算机并修改计算机的状态。

对于这个简单的程序，我们只做一件事：在控制台上打印一行文本。当然，作为一个运行在多用户系统(比如现代的Linux)上的底层的程序，我们不能直接与显示硬件进行交互，然后来改变屏幕上显示的内容(我们也不想这么做，因为这意味着我们需要对所有我们想要支持的显卡有深入的了解，还需要让我们的程序不能与其他程序同时运行)。因此，我们告诉操作系统我们想要打印到控制台上的内容，而操作系统将会为我们完成剩下的所有工作。而这种告诉操作系统的方法就是执行系统调用。我们将设定一些寄存器，这些寄存器将会向操作系统解释我们希望操作系统做什么工作，然后当我们准备好的时候告诉操作系统。这些步骤需要多行代码，但概念上它们组成了一个单一的操作。

```assembly
global _start
_start:
```

这两行做的是不同的事，但两者紧密相连。基本上，这两句定义了程序的入口点。当程序运行时，"_start:"的下一行将会首先执行。总体上就是告诉计算机运行程序时从哪条指令开始。

```assembly
    mov rax, 1
```

这一行是第一个真正的代码行：处理器实际上执行的第一条指令。接下来进一步分解它：

- **mov**是指令类型，或者说是操作码，opcode。它是一个命令，用来告诉处理器要执行什么样的操作。在这个例子中，`mov`代表“移动”。它用于在寄存器和内存之间移动数据和值。稍后我们会详细介绍这些内容，但是现在你可以视它为一种改变信息位置的方法，使得信息稍后可以处理或者存储。

- **rax** 指的是一个寄存器。它是一个临时存储位置，其值可以被写入、读取或者操作。实际上有很多寄存器，比如：rax，rbx，rcx，rdx，rbp，rsp，rdi，rsi等。这些寄存器大部分都有着特殊的用途或者保留用于某些特定事物。但rax不是，它是一个通用的寄存器。这意味着程序员可以根据需要随意使用它。如果你熟悉某些更高级别的语言，这可以将寄存器看成是内置的全局变量。实际上，它们比一般的变量要快得多，因为它们不在系统的内存中，而是在处理器本身的内部。
- **1**是立即值，立即值意味着值“1”直接编码到指令中。我们不是从一个寄存器或一个内存地址中移动信息，它只是字面值“1”。

总之，这条指令告诉处理器将值1放入寄存器`rax`。它可以被理解为“将1移入rax”。如果您习惯使用高级编程语言，可以将其视为`rax = 1`。

执行该指令后，`rax`将被设置为值1。这是因为我们正准备调用操作系统。1代表 *sys_write*，它将会告诉操作系统去将一些数据写入一个文件或流。`rax`是操作系统用来弄清楚程序想要操作系统做什么的寄存器。

```assembly
    mov rdi, 1
```

这一条语句和上面的相似，但在这里，我们是将值1加载到寄存器中`rdi`。在这个上下文中，1代表STDOUT，表示写入控制台。这也可以是2，2的话表示写入STDERR，而STDERR通常是用来写入错误。

执行该指令后，`rax`和`rdi`都会被设置为值1。

```assembly
    mov rsi, message
```

我们之前已经告诉了操作系统我们要写一些数据（`rax`= 1），我们也告诉了操作系统在哪里写这些数据（`rdi`= 1）。现在我们需要做的就是告诉操作系统要写什么。在这里，我们设置`rsi`为“Hello，world！”字符串的开头。当操作系统检查这个寄存器来查看需要写入STDOUT的数据时，它将得到内存中message字符串开头的位置。即这一行将内存中的message的开头的地址赋予`rsi`寄存器。

```assembly
    mov rdx, 14
```

现在我们告诉操作系统*message*有多少字节要写。这好像有点奇怪。这是因为当我们设置`rsi`为*message*时，我们并没有真正设置 `rsi`为整个字符串“Hello，world！”。在一个64位的处理器上，每个寄存器比如`rsi`仅仅具有64位，即8字节。而字符串“Hello, world!” 是ASCII，每个字符占一个字节，加上最后的换行符，总共需要14个字节来存储。因此，将整个字符串一次性全部存储在单个寄存器中是不可能的。我们所做的只是将内存中字符串开始的位置存储在寄存器中。

当操作系统去检查时`rsi`时，它不会看到“Hello, world！”，而是看到一个地址，这个地址指向内存中字母“H”所在位置。通过不断阅读下一个地址，它将能够看到“Hello，world!”包含的所有内容，一次一个字符。然而，操作系统无法知道何时应该停止。在读完整个字符串之后，它将继续读取内存中该字符串之后的任何内容，有可能是未初始化的垃圾数据，也有可能是该程序的其他值或字符串，甚至可能是该程序不允许访问的内存。所以这种情况下，我们必须告诉操作系统什么时候停止。实现的方法是将`rdx`的值设置为要打印的字节数或者字符数。在这个程序中，这个数字为14，即整个字符串“Hello，world!” 和尾随的换行符(10)加起来的长度。

```assembly
    syscall
```

这一行是系统调用，让操作系统知道我们有一些工作要它做，并且该工作的细节已经加载到适当的寄存器中。执行该指令时，控制权将从我们的程序转移到操作系统。操作系统将检查我们加载到寄存器`rax`、`rdi`、`rsi`和`rdx`中的值`，然后使用这些值来决定该怎么做。

操作系统将执行以下操作：

1. 检查`rax`看应该做什么，发现值1，值1表示sys_write。这意味着有一些数据要写。
2. 检查`rdi`看数据应该写到哪里去，发现值1，值1代表STDOUT（控制台）。
3. 检查`rsi`看要写入什么数据，发现字符串在内存中的首地址。
4. 检查`rdx`看要写入多少数据，发现14，即要写入数据的长度。
5. 最后，通过以上4个指示，操作系统将从“Hello，world！”中的“H”开始写，一共要写14个字符到控制台，写完后将控制权返回给我们的程序。

## 2 Running the program

在文本编辑器中键入上述程序，并将文件另存为“hello.asm”。在实际运行之前，还有两个必要的步骤。

首先，需要使用汇编将程序转换为机器代码。在这里，我们使用名为*nasm*的程序来执行此操作。在终端上，键入以下命令并按Enter键。确保你已经进入文件“hello.asm”所在的目录中，否则*nasm*找不到hello.asm。

```
nasm -f elf64 hello.asm
```

这一行语句运行nasm程序，告诉它将“hello.asm”进行汇编。执行后，“hello.asm”的内容将从汇编语言转换为机器代码，这些机器码将被写入名为“hello.o”的新文件之中。这个新文件称为目标文件。

`-f elf64`是一个选项，这个选项告诉nasm所要汇编的是一个64位程序。如果没有这个选项或者参数，nasm将默认“hello.asm”是一个32位程序，然后汇编失败。

如果nasm报告了什么错误，请检查是否按照上面的方式键入了该程序，然后重试。如果nasm运行成功，将不会有任何输出。

文件“hello.o”现在应该在“hello.asm”所在的文件夹中。这是程序的机器码版本。编写的代码已转换成了计算机能够执行的格式。

然而，它现在还不能运行，因为它现在只是一大堆机器代码和数据。操作系统不知道该对它做什么。为了让操作系统理解它，我们必须使用一个链接器将“hello.o”转换成一个可执行文件格式。在这个例子中，我们使用GNU 链接器(称为*ld*)，*ld*将目标文件转换为可执行文件，并默认将该可执行文件命名为“a.out”：

```
ld hello.o
```

接下来就是操作系统运行该可执行文件了：

```
./a.out
```

如果一切顺利，将会看到以下输出：

```
Hello, world!
Segmentation fault (core dumped)
```

而这并不是我们所希望看到的。

## 3 Segmentation fault!

上面的程序有一部分正常工作，它按预期将字符串写入到控制台，但后面遇到了一个非常讨厌的错误：段错误。

一个段错误基本上意味着操作系统不喜欢程序所做的或试图做的。通常来说，当程序试图访问它不拥有的内存，或者程序以无效的方式使用指令时，就会发生这种情况。段错误让人非常沮丧，因为对于究竟发生了什么甚至错误是在程序哪里发生的，它们能提供的信息很少。

当然在这里，原因并不复杂：我们忘了退出程序。操作系统期望在程序运行完毕后，程序会告诉操作系统。而我们没有那样做：我们在控制台上打印了一个字符串，然后什么也没做。操作系统无法知道我们是否真的完成了所有任务，也不知道它是否应该继续尝试运行指令。要解决此问题，我们需要在执行控制台打印调用后，执行另一个系统调用。

将以下代码添加到程序的末尾：

```assembly
    mov rax, 60
    mov rdi, 0
    syscall
```

这些代码看起来非常熟悉，接下来对它们进行分析：

```assembly
    mov rax, 60
```

我们准备对操作系统进行另一个系统调用，但这次是使用不同的命令，而不是1(意味着*sys_write*)。这次是传递60给`rax`，60意味着*sys_exit*。这告诉操作系统我们的程序已运行完毕，可以安全地将其关闭并从内存中删除。

```assembly
    mov rdi, 0
```

接下来我们设置`rdi`为0。这是退出状态代码。每当程序完成时，它返回一个状态代码，其他程序可以使用它来确定程序是否成功完成。在这个例子中，程序没有出错，所以我们返回0，表示运行成功。

```assembly
    syscall
```

最后，我们进行系统调用。控制权从程序转移到操作系统，操作系统将执行以下操作：

1. 检查`rax`看应该做什么，发现值60，值60表示sys_exit。这意味着要结束这个程序。
2. 检查`rdi`看程序的退出状态代码，发现值0，值0代表运行成功。
3. 最后，通过上述2个指示，操作系统将关闭程序并将其从内存中删除，然后将0返回给控制台。



保存这些更改后，重新汇编、重新链接并重新运行程序：

```
nasm -f elf64 hello.asm
ld hello.o
./a.out
```

将会看到控制台输出以下内容：

```
Hello, world!
```

这说明我们以操作系统期望的方式退出程序，所以段错误消失了。如果想要查看错误代码，可以运行以下命令：

```
echo $?
```

这一行将打印出上次程序运行的状态代码。由于`rdi`在返回之前被设置为0，因此在这种情况下将返回0。尝试将`rdi`的值更改为其他内容，看看`echo $?`的结果将会是什么。

*注意：如果运行多次echo $?，在第一次运行后总是显示为0。这是因为echo本身就是一个如果运行成功就返回0的程序。因此，如果运行两次，那么在第二次运行时，它将报告上一次运行echo的退出代码，而不是之前运行的程序的状态代码。*

## 4 Improving the code

这个程序还有一些问题。首先，我们使用了很多*magic number*：比如1,0和60，它们具有特殊的含义，但仅限于某些特定的上下文。这有损该程序的可读性。任何时候你都可以尝试避免使用这些*magic number*，因为它们在不提供任何其他好处下使得程序难以阅读。

解决此问题的一个简单方法是使用宏。*nasm*中的宏允许程序员定义一串描述性文本，当进行汇编时，这些描述性文本将被其他内容替换。宏如下所示：

```assembly
%define sys_write 1
```

这个宏定义告诉*nasm*在汇编期间用值“1”替换所有出现的单词“sys_write”。我们可以用它来改进程序的可读性：

```assembly
%define sys_write 1
%define stdout 1

%define sys_exit 60
%define success 0

%define nl 10

section .data

    message db "Hello, world!", nl

section .text

global _start
_start:
    mov rax, sys_write
    mov rdi, stdout
    mov rsi, message
    mov rdx, 14
    syscall

    mov rax, sys_exit
    mov rdi, success
    syscall
```

现在更容易看出程序正在进行哪些系统调用，以及这些系统调用正在做什么，前面程序中的整数现在都有描述性的文本，而不是分散在整个代码中。

但是仍然有一个*magic number*：14，它对应到*message*字符串所包含的字符数。此外，它还取决于程序中的另一个值。如果我们要将*message*的值更改为其他文本，我们还必须记住要更新`mov rdx, 14`这一行，以匹配新的*message*长度。在这样一个简单的程序中，这不是什么大问题。但是在很多复杂的程序里，可能包含数百或数千条指令，某一个字符串可能会在整个代码中重复使用多次，可能需要大量的系统调用并不断更新字符数。而这会导致我们很容易错过一些需要更改的地方。此外，根据我们测试程序的程度，我们甚至可能都没有意识到我们错过了一个需要更改的地方，直到很久以后该程序的用户报告了一个错误。

为了解决这个问题，我们可以使用nasm的一个特性，它允许我们定义一个符号，这个符号的值自动设置为字符串的长度：

```assembly
    message_len equ $-message
```

这一行语句将符号*message_len*设置为*message*中所包含的字节的数目。所以每当汇编程序碰到“message_len”，它就用*message*的字符的数目替换它 。更改完的程序如下所示：

```assembly
%define sys_write 1
%define stdout 1

%define sys_exit 60
%define success 0

%define nl 10

section .data

    message db "Hello, world!", nl
    message_len equ $-message

section .text

global _start
_start:
    mov rax, sys_write
    mov rdi, stdout
    mov rsi, message
    mov rdx, message_len
    syscall

    mov rax, sys_exit
    mov rdi, success
    syscall
```

再也没有*magic number*！你可以更改文本“Hello，world!” 为任何你想要的东西，而不用更新打印它的系统调用。像0,1和60这样的文字值仍然出现在代码中，但是它们已被定义， 一眼就可以看出它们的含义。 `_start:`下面的代码更清晰，代码的作用更明显。

## 5 Extra credit

1. 让程序打印出多个“Hello，world!" 。
2. 更改程序，使其打印几个不同的消息，而不仅仅是“Hello，world！”。



