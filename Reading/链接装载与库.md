

## 从源码到程序

程序最初的存在形式是源代码，也就是若干个`.c`文件。它要想变成一个可执行的程序，需要以下几个步骤：

1. 预编译(P39)：负责这一步工作的叫“预编译器”。它主要负责处理所有的`#define`宏定义；所有的预编译指令，比如`#if`、`#endif`等。接下来会递归处理`#include`指令，用被包含的文件替换这个预编译指令。`.c`文件经过预编译，变为`.i`文件。

2. 编译(P42)：这一步由编译器负责，主要又由词法分析、语法分析、语义分析、优化和生成汇编代码五个部分：

   - 词法分析：识别源代码中的各种括号、数字、标点等。比如有`(`但没有`)`，这一步就能发现错误
   - 语法分析：这一步会生成语法树，比如`2+4`就是一颗根节点为`+`，左右叶子节点分别为`2`和`4`的语法树。如果你只是写`2+`，在这一步就会报错。
   - 语义分析：这一步主要考虑类型声明、匹配和转换。比如你写`2 * "3"`在这一步就会报错
   - 中间语言生成：这一步会生成平台无关的三地址码，比如`2 + 3`会写成`t1 = 2 + 3`，同时也会把这样在编译期就可以确定的表达式进行优化
   - 目标代码生成：编译器根据三地址码生成依赖于目标机器的目标机器代码，也就是汇编语言。

   `.i`文件经过编译，得到汇编文件，后缀是`.s`

3. 汇编(P40)：这一步由汇编器负责，将汇编语言转换成机器可以执行的语言(完全由0和1组成).汇编文件经过汇编，变成目标文件，后缀为`.o`。

4. 链接(P41)：这一步是这本书的重点。之前的几个步骤，都是以`.c`文件为基本单位，一个`.c`源代码文件最终被汇编，生成目标文件。这一步就是处理如何把多个目标文件链接起来。

   考虑一个`.c`文件中，用到了另一个`.c`文件中的变量或函数。在编译这个文件时，我们无法在编译期确定这个变量或函数的地址。只有在把所有目标文件链接起来以后，才能确定。链接器主要负责地址重分配、符号名称绑定和重定位。

从源代码到程序的运行要做的远远不止编译，很多时候我们说“把程序编译一下”，是不准确的。不过编译确实是整个流程中最复杂的部分。

## 软件调用层次

我们把整个计算机调用结构分为四层：

1. 最上层是应用层。不管是浏览器、游戏，还是我们使用的各种开发工具，如Xcode，VS，汇编器自身等，都属于这一范畴。
2. 第二层是操作系统的运行库。我们在程序里调用系统API，比如文件读写，就是调用了第二层提供的相应服务。这种调用通过操作系统的API完成，它沟通了应用层和操作系统的运行库。这也就是为什么不管是在Mac还是Windows上编程，我们都可以调用`printf()`或`fread()`等函数。因为不同的操作系统的运行库提供了不同底层的实现，但对应用层提供的API总是一样的。
3. 第三层是操作系统内核。操作系统的运行库通过系统调用(System Call)调用系统内核提供的函数。比如`fread`属于API，它在Linux下会调用`read()`这个系统调用，而在Windows下会调用`ReadFile()`这个系统调用。应用程序可以直接调用系统调用，但是这样一来，我们需要考虑各个操作系统下系统调用的不同，而且系统调用由于更加底层，实现起来也就更加困难。最关键的是，系统调用是通过中断来完成的，涉及到堆栈的保存与恢复，频繁的系统调用会影响性能。
4. 第四层是硬件层。程序无法直接访问这一层，只有操作系统的内核，通过硬件厂商提供的接口才能访问。



### 静态链接

这一部分主要是讨论多个`.c`文件怎么通过静态链接，得到一个静态库。

- P58

  目标文件中分为若干个段，比如.text段存放代码，.data段存放存放已初始化的全局变量和局部静态变量，.bss段存放未初始化的全局变量和局部静态变量，除此以外目标文件还有很多其他的段。

- P70

  Linux下的目标文件还有一个ELF文件头，用于汇总这个目标文件的各种信息,其中包括了ELF魔数、机器字节长度、数据存储方式、版本、运行平台、ABI版本，重定位类型、硬件平台及版本、入口地址、段表位置、段的数量等。

- P74

  段表其实是一个数组，其中每一个元素都是结构体。结构体里面有段的名称、类型、加载地址、相对于文件头的偏移量，段的大小，链接信息等。

- P79

  目标文件中还有一个重定位表。需要重定位的信息都记录在这个表里面。.text段中所有需要重定位的信息，都放在.rel.text段中。

- P81

  在链接时，我们把函数名和变量都称为符号。每一个函数、变量都有自己独特的符号名，这样在链接时才能把它们对应起来。不同的语言有自己的符号修饰规则。UNIX下的C，编译出来的符号名前面加“_”，如函数foo在编译之后的结果为_foo。

- P86

  C++的namespace就是用来避免符号名冲突。C++有一套自己的符号名修饰规则，可以通过c++filt命令还原被修饰过的符号名(demangle)。一旦了解了符号名的修饰规则，在写iOS时遇到`undefined symbol`或`duplicate symbol name`的报错，就非常好检查了。

- P92

  符号分为强符号，和弱符号。强符号不可名称重复，弱符号（未初始化的全局变量）可以有符号名相同。对符号名的引用分为强引用和弱引用，强引用表示如果找不到符号定义会报错，弱引用不报错，默认为0或某个特殊值。

- P99

  链接过程一般分为两步，首先地址分配，然后符号解析并重定位。

  由于不同的目标文件，可能含有相同的段，所以在链接过程中，我们可以合并相似段，这就是地址分配。

  合并完成后，所有符号的位置都可以唯一确定，此时可以就开始重定位工作了。链接完成后，我们就得到了静态库。

- P118

  静态库可以看做一组目标文件的集合，同一个静态库中的不同目标文件可能相互依赖，不同的静态库也可以相互依赖。

- P127

  链接控制脚本控制链接器的运行，将目标文件和库文件转化为可执行文件。链接控制脚本由链接脚本语言写成。可以认为的控制程序入口，某几个段合并，某几个段舍弃等

### 动态装载

这一部分主要是讨论经过链接后，可执行文件如何装载到内存中

- P153

  有两种典型的动态装载方法：覆盖装入和页映射。覆盖装入允许互不依赖的两个模块共同享有同一块内存，在使用中互相替换。速度较慢，用时间换空间。我们常用的方案是页映射，把程序虚拟的内存空间分成多个页，由专门的页装载管理器负责管理虚拟页和物理内存中页的对应关系。

- P157

  创建进程三步骤：首先进程自己的创建物理空间。设置好虚拟空间中各个页到物理空间里的页的映射关系（这一步可能在页错误之后发生）、然后建立虚拟空间与可执行文件的映射关系。Linux下，目标文件的每个段都有自己在虚拟内存中的位置，这叫虚拟内存区域（VMA, Virtual Memory Area），表示它装载在虚拟内存中的地址，最后指令寄存器设置为可执行文件入口。

- P159

  进程创建后，只有物理页与虚拟页的对应关系，但是真正的指令和数据还没有放入物理页中，物理页的内存处于未分配状态。一旦访问到这个物理页，就会发生页错误。

  发生页错误时，操作系统立刻根据物理内存的页与虚拟内存的页的对应关系，找到这个页对应的虚拟内存，然后再查询每个段的VMA，就可以找这个页面在可执行文件中的偏移量。这时候操作系统先为物理页分配内存空间，然后把可执行文件中的数据和指令写入物理页，最后建立物理页和虚拟页联系即可。然后进程从发生页错误的地方重新执行。

- P169

  可执行文件有很多Section，它们的大小各不相同，但有些小于页的大小，导致了空间浪费（不能连续存储不同的section是因为可能会有两个权限不同的section在同一个页中）。由于操作系统不关心每个Section的具体作用，但是关心它们的读写权限（是否可读、可写、可执行），所以往往把具有权限的Section合并成一个Segment

- P172：

  进程运行后，操作系统会初始化进程的堆栈，其中存放了环境变量和命令行参数。这些参数被传给main函数（argc和argv两个参数对应参数数量和参数数组）

### 动态链接

- P181

  动态链接把程序按模块拆分成若干个相对独立的部分，模块之间的链接推迟到运行时。ELF的动态链接文件成为“动态共享对象（DSO）”，后缀为“.so”。动态链接的过程由动态链接器完成。动态链接可以节约内存（多个进程共享内存中的某一个模块）、方便升级（静态链接的每一个模块都会影响整个可执行文件）。

- P188：

  由于动态共享对象会被多个程序使用，导致它在虚拟地址空间中的位置难以确定。不同模块的目标装载地址如果有相同的，那么同时导入这两个模块就会出问题。如果都不一样也不行，因为可能存在的模块太多了。没有那么多内存。所以动态共享对象需要在装载时重定位。

- P191：

  装载时重定位会导致无法在多个进程间共享，目前采用的方案是地址无关代码技术。动态对象中的地址引用分为模块内部和外部，指令引用和数据引用，两两组合成四种。对于模块内部的指令或数据引用，采用相对偏移调用的方法。

- P195：

  把地址相关需要重定位的部分放到数据段中，同时建立全局偏移表（GOT）。用.got和.got.plt表分别处理数据和函数引用。

- P200：

  当函数第一次被用到的时候才重定位，从而提高程序运行速度。这种方法被称为延迟绑定（Lazy Binding）。Linux维护一个PLT（Procedure Linkage Table）来保存符号名和真实地址之间的对应关系

- P208：

  动态链接中有两个重定位表.rel.dyn和.rel.plt分别对应.rel.text和.rel.data。前者对数据引用（.got）进行修正，后者对函数引用(.got.plt)进行修正。

- P214：

  动态链接器是一个特殊共享对象，它不依赖于任何动态共享文件，且自己的重定位工作由自己完成。通过一段被称为自举（Bootstrap）的特殊代码，不用到任何静态或全部变量，完成这项工作

### 内存与库

- P286：

  i386处理器下，栈顶有esp寄存器定位，由于栈向下生长，压栈使得栈顶地址减小

- P287：

  栈保存了函数调用所需要的维护信息，被称为堆栈帧（Stack Frame）或活动记录，包含了函数的返回地址和函数，临时变量以及保存的上下文。ebp是帧指针指向活动记录的某一个固定位置。

- P294：

  函数的调用方和被调用方要遵守同一个“调用惯例”。默认的cdecl惯例要求函数参数以从右到左的顺序入栈，由函数调用方负责参数的出栈。

- P301：

  函数返回值的获取：如果是四个字节，放在eax中。4-8字节的返回值通过eax（低位）和edx（高位）联合存储。查过8字节的返回值，把返回值在栈中存放的地址放到eax中。

- P306：

  栈上的数据在函数返回时就会被释放，全局地、动态的申请内存的方式是利用堆。如果由操作系统管理堆，由于总是进行系统调用，性能开销比较大，所以一般由应用程序“批发”一大块内存空间，然后自己进行内存管理。

- P311：

  堆并不总是向上生长（如Windows的HeapCreate系列），调用malloc有可能产生系统调用（取决于进程预申请的空间是否足够），堆内存在进程结束后被操作系统回收，堆内存在虚拟地址空间中连续，在物理空间中可能不连续

- P314：

  堆分配三种算法：空闲链表（简单，记录长度的字节容易被数组越界破坏）、位图（速度快（容易命中cache），稳定性好（不容易数组越界），易管理，会产生碎片，位图有可能过大）、对象池（针对固定大小的分配空间）

- P319：

  创建进程后，操作系统把控制权交给运行库的某个入口函数，然后开始堆的构造，启动I/O，创建线程，进行全局变量构造等。然后调用main函数，main函数执行完成后，执行与之前相反的操作，进行系统调用结束进程。



Reference: [https://www.polarxiong.com/archives/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%9C%A8%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB.html](https://www.polarxiong.com/archives/静态链接与动态链接在链接过程和文件结构上的区别.html) 

