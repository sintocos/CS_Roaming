## Object-oriented programming

#### 1. Overload(重载) 与 Override(重写/覆盖)

Overload: **同一类**之中多个方法，**参数的数量和类型不同**，但**返回值和方法属性一致**。为了增加通用性。

Override:  **父子类**之中对应方法，**参数的数量和类型相同，返回值和方法属性一致**，但**内核变了**。为了多态。

想象Overload是水平上排列的一系列方法，叫同一个名字，上面落下不同的数据，进入不同的方法中，但返回的结果一样。即数据先分散到不同的方法中，再聚合到一处。

想象Override是在一个栈，这一系列方法都在这个栈中，父类的方法在底下，最新的子类的方法在最上面。外观看上去一样，但看到的永远是栈定的那个方法。

refer: https://www.runoob.com/java/java-override-overload.html



#### 2. C++虚函数

Virtual Function 主要是为了实现动态多态性，晚绑定。指的是当基类指针指向其派生类实例时，可以**用基类指针调用派生类中的成员函数**。如果基类指针指向不同的派生类，则它调用同一个函数就可以实现不同的逻辑，这种机制可以让基类指针有“多种形态”，它的实现依赖于虚函数表。

1. 虚函数表(Virtual Table)是指在每个包含虚函数的类中都存在着一个函数地址的数组。

2. 类对象保存指向虚函数表的指针，大小为4个字节。这个虚函数表的地址总是存在类的实例对象的最前面，然后才是对象实例的成员。而虚函数表里面从上到下存着类的虚函数的地址。

3. 对于派生类覆盖了基类的虚函数的情形，记住两点：1.虚函数表中派生类覆盖的虚函数的地址放在基类对应的函数原来的位置，2.派生类没有覆盖的虚函数沿用基类的。

4. 纯虚函数是虚函数再加上=0。并且该函数只有声明，没有实现。抽象类是指包括至少一个纯虚函数的类。

5. 运行时多态(动态多态)是通过虚函数实现的，但编译时多态(静态多态)是通过重载函数实现的。前者函数调用的地址在编译时不能确定，需要在运行时才确定，属于晚绑定。后者在编译时就能确定函数的调用地址，并生产代码，属于早绑定。

6. 虚函数的调用关系是this->vptr->vtable->virtual function。静态与非静态成员函数之间有一个主要的区别，即静态成员函数没有this指针，所以static函数不能为虚函数。this相当于Python里面的self。

7. 以下这些函数不能为虚函数：

   1. 构造函数，构造函数用来初始化对象，virtual table也在构造函数中初始化；

   2. 内联函数，其在编译阶段就进行了函数体的替换，而虚函数是在运行时进行类型确定；
   3. 静态函数，静态函数属于类而不属于对象，没有this指针；
   4. 友元函数，其不属于类的成员函数，无法继承。没有继承特性的函数没有虚函数的说法；
   5. 普通函数，和友元函数类似，不属于类的成员函数，无继承特性。

8. 析构函数可以为虚函数，但最好不要为纯虚函数。







#### 3. C++ 内存管理

一个由C++编译的程序占用的内存可以分为以下几个部分：

1. 栈区(stack)，由编译器自动分配释放，存放**局部变量**和**函数的参数**等。其操作方式类似于数据结构中的栈。 

2. 堆区(heap) ，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。一般来说这里比较容易发生内存泄漏。 

3. 全局区/静态区(static)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 

4. 文字常量区，常量字符串就是放在这里的。程序结束后由系统释放 

5. 程序代码区，存放函数体的二进制代码。 

下面是一个main.cpp的示例：

```c++
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 

void main(){ 
	int b;// 栈 
	char s[] = "abc"; //栈 
	char *p2; //栈 

	char *p3 = "123456"; //"123456"在常量区，p3在栈上。 

	static int c =0; //全局(静态)初始化区 

	p1 = (char *)malloc(10); 
	p2 = (char *)malloc(20); //分配得来的10和20字节的区域就在堆区。 

	strcpy(p1,"123456");//"123456"在常量区，编译器可能会将它与p3指向的"123456"优化成一个地方。 
} 
```



#### 4. Python 内存管理

Python是用C实现的。在Python世界中，一切都是对象。整数、字符串、类型(如字符串类型)等都是对象。

在Python中，对象就是：为C中的结构体在堆上申请的一块内存。

所有的内建的类型对象(如整数类型对象、字符串类型对象)都是被静态初始化的。

在Python中，一个对象一旦被创建，它在内存中的大小就是不变的(而Java在堆上new的对象是在运行时动态分配内存的)。如果要容纳可变长度数据的对象，只能**在对象内维护一个指针指向一块可变大小的内存区域**。

Python提供了对内存的垃圾收集(GC)机制。

Python中所有的内存管理机制都有两套实现。这两套实现由编译符号PYMALLOC_DEBUG控制。当该符号被定义时，使用debug模式下的内存管理机制。这套机制在正常的内存管理动作之外，还会记录许多关于内存的信息，以方便Python在开发时进行调试。当该符号未被定义时，Python的内存管理机制只进行正常的内存管理动作。





#### 5. Java内存管理

Java把内存划分为4个部分：

1. 栈区(stack segment)，由编译器自动分配释放，存放函数的参数值以及局部变量的值等，具体方法执行结束之后，系统自动释放JVM内存资源。
2. 堆区(heap segment)，一般由程序员分配释放，存放由new创建的对象和数组，JVM不定时查看这个对象，如果没有引用指向这个对象就回收。
3. 静态区(data segment)，存放全局变量、静态变量和字符串常量，不释放。
4. 代码区(code segment)，存放程序中方法的二进制代码，而且是多个对象共享一个代码空间区域。

Java自动管理栈和堆，程序员不能直接地设置栈或堆。

当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。

栈有一个很重要的特殊性，就是存在栈中的数据可以共享。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的。前者a的修改并不会影响到b，它是由编译器完成的，它有利于节省空间。而后者一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。



#### 6. 对象和类





#### 7. 继承，封装，多态

为什么要这些？可见性，控制复杂度，以及其他(待补充)

怎么实现

优缺点

#### 8.面向对象与面向过程对比

优缺点对比，补充其他编程范式

