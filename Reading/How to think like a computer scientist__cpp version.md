### 像计算机科学家一样思考(C++版)

用形式化语言表达思想，尤其是计算思想；

设计组件、合成系统并权衡各种备选方案；

观察复杂系统的行为、形成假设并进行检验 。

#### Chapter 1 编程之路

1. 高级语言和低级语言区别

2. 解释和编译区别，编译基本流程和每一步所做的事

3. 源代码和目标代码、可执行文件



4. 语言基本功能：输入、输出、数学运算、测试、重复。

5. 编程是将复杂的任务进行分解成越来越小的子任务，直到子任务简单到可以用编程语言的基本功能来执行。

6. 调试(debug): 编译时错误(语法问题)，运行时错误，逻辑和语义错误(正确编译和运行，但得不到预期结果)。

7. 编程某种程度上就是逐步调试程序直到它满足要求为止。

   

8. 编程语言是人为设计的用来表达计算的形式语言。形式语言有严格的语法规则。

9. 语法规则包含两方面：标识符与结构。阅读自然语言或形式语言时，需分析标识符和语句结构，即解析语句。

10. 自然语言和形式语言都有：标识符，结构，语法，语义。

11. 自然语言通常用歧义，并且为了消除歧义，有很多冗余，此外，自然语言还有很多成语和隐喻，即自然语言的语句的含义和字面意义并非完全一致。

12. 形式语言没有歧义，任何语句都有一个精确的意义，所以相对比较简洁，没有什么冗余。此外，形式语言的语句的含义和字面意义是完全一致的。

13. 首先，形式语言或者程序相对难以阅读，其次，结构对形式语言非常重要。阅读代码时要先在脑海里面分析程序，了解其句子结构。最后，细节对程序非常重要，拼写或者符号错误可能造成天壤之别。



#### Chapter 2 变量和类型

1. 换行符、空格、注释可以把程序组织得更直观，使程序更易读，也更易于定位语法错误。

2. 值是程序处理的基本元素，就像字母或数字一样。

3. 变量是存放值的一个位置，我们给这个位置赋予了名字。

4. 创建一个变量时，应该先声明它的类型，这种语句一般称为声明语句。

5. 变量的类型决定了它能存储什么值，或者说决定了程序对变量对应的那个内存位置里面的01串如何理解。

6. 变量名应当反映这个变量的用途，即变量名应当有意义。

   

7. 创建变量后，如果想用变量来存一些值，可以使用赋值语句。声明和赋值组合起来称为初始化。

8. 注意声明和赋值的区别，声明是创建一个有名字的存储位置，赋值是对那个位置进行写入。

9. 基本规则是变量和值应当具有相同的类型，但有时赋值C++会进行自动转换。

10. 赋值语句的左边必须是一个变量名，而不能是一个表达式，因为左侧表示结果的存储位置，表达式仅表示值，无存储位置。

    

11. C++关键字、操作符、操作符的操作顺序(优先级规则)

12. 自动类型转换，操作符重载需要注意，这是为了编程的便利性而牺牲了形式语言的简单规则。

    

13. 编程语言的一个基本特性就是能够使用小的构件来组合成大的程序。



#### Chapter 3 函数

1. 函数、函数的参数、函数的组合、函数的调用、函数栈

2. 函数定义：返回类型，函数名，参数列表，函数语句。

3. 函数的定义必须出现在第一次使用之前。程序往往从main函数的第一句开始执行，然后逐条执行，直到碰到函数调用。函数调用需要需要保护现场环境/上下文，所以函数调用是有代价的。

   

4. 参数类型与参数值，值传递、引用传递、指针传递的区别。

5. 作为参数值传给函数的变量名跟函数的参数名没有任何关系。

6. 实参和形参，默认参数，函数也可以作为参数传递为另外一个函数。

7. 参数和变量的局部性/局部帧/全局帧/环境/名称空间，都是对可见性的反映，控制其可见范围，从而控制编程的复杂度。



#### Chapter 4 条件和递归

1. 条件执行、选择执行、链式条件、嵌套条件。
2.  return语句允许在一个函数执行到结尾之前终止它的执行。
3. 递归、循环、迭代对比，尾递归，无穷递归与堆栈溢出。递归：一个函数调用自身的过程。



#### Chapter 5 函数使用

1. 函数声明了返回类型，则一定要有返回值，且返回值的类型要和声明的类型一致。

2. 确保函数无论多少个分支执行，必然有一个分支能碰到return语句。

3. 当程序有错误时，不出现编译错误会比出现更糟糕。 

4. 通常，main的返回值为0，表明程序成功执行，而出错一般返回-1。main函数由系统调用，返回值也是返回给系统，这和main函数调用其他函数一样。有时候，系统会给main传递一些参数。

   

5. 增量开发：先写函数轮廓进行样本测试，然后写函数实现，不断完善所有情况，一行一行添加代码。每次增量改变，就重新编译并运行程序，从而，一旦出现错误，就知道错误必然出现在新增加的代码中。

6. 开发的过程中，可能包含大量断言、输出之类的语句，这种代码称为支架代码，有助于构建代码，但并非最终产品的组成部分。有时删除代码，但更多情况是注释掉，以防后面用到。

7. 开发过程中，可以使用临时变量保存中间值，以便于输出并验证它们。程序工作正常后，可以使用组合函数调用来使代码更简洁，这时候就可以消除一些临时变量了。

8. 调试的一个基本规则：一定要确认你正在看的程序版本和就是正在运行的版本！

   

9. 函数重载：函数名相同，但参数数目或者参数类型不同，编译器会根据参数自动选择应该调用的函数。C++有很多内置函数使用函数重载。



#### Chapter 6 函数使用II

1.  while语句，do while语句， for语句

2. 封装：提取出一段代码，包装在一个函数里面。

3. 泛化：提取出特例的代码，修改后使之更加通用。泛化其实是抽象具体数据到函数的参数中去。

4. 在适合的地方使用函数：1.函数可以给一组语句起名字，便于程序的阅读和调试；2.把一段长程序分割成多个函数，便于分解程序，独立调试，然后整合成一个整体；3.函数式递归和迭代变得方便；4.函数可以更加代码复用，设计良好的函数通常用于许多程序。

   

#### Chapter 7 字符串

1. 字符串常用操作：遍历，截取，拼接，取长度，查找，比较等
2. 对于某个字符串temp，取长度可用temp.length()，对于这种函数调用，称之为在字符串变量temp上 invoke(也可以翻译为调用)length函数，在对象上调用函数。

#### Chapter 8 结构体

1. C++提供了两种机制-结构体和类-来让用户创建自己的复合值。这样的话，可以将复合类型当做单个事物或对象，也可以访问它的某部分或实例变量。

2. 结构体和类的区别，结构体中的元素(实例变量)。

3. 定义一个结构体如下：

   ```c++
   struct Point{
   	double x,y;
   };
   
   Point blank = {3.0, 4.0}; //初始化可直接使用大括号，这时大括号里面的值依次赋给结构体的实例变量
   
   Point foo;
   foo = {3.0, 4.0}; //这个是错误的，以上的语法只能出现在初始化中，而不能在赋值语句中。
   
   Point bar;
   bar = (Point) {3.0, 4.0}; //这个是可行的，因为此时编译器知道右边是什么类型。
   ```

4. 通过引用传递结构体比较常见，一是可以对结构体进行修改，二是不用复制。按值传递时，实参和形参是在不同环境/帧中的两个变量，只是最初有着相同值而已，这就要求复制。传值的好处在于进行了适当的封装和隔离，其中一方的修改不会影响到另外一方。

5. 按引用传递时，注意参数必须是有地址的，一个好的规则就是只用变量作为引用参数。

   ```c++
   void swap (int& x, int& y)
   {
      int temp = x;
      x = y;
      y = temp;
   }
   
   int i = 7;
   int j = 9;
   swap (i, j);
   cout << i << j << endl;//可行，输出97
   
   swap (i, j+1); //错误！因为j+1这个表达式并不是一个变量，即它没有占据一个可以引用的地址。
   ```

   

6. 结构体中可以包含另外一个结构体，想象框嵌套。结构体也可以作为返回值，函数的返回值类型要声明为该结构体类型。

7. 基本的用户输入输出，cin cout printf getline等。

#### Chapter 9 函数使用III

1. 操作于对象的函数的几种可能的接口形式: 1.**纯函数**：对象与/或基本类型作为参数值，但是不改变对象本身。返回值要么是一个基本类型值，要么是函数内部创建的一个新对象。2.**修改函数**：对象作为参数，并且会修改其中一部分或者全部对象，通常返回值为空。3. **填充函数**：空对象作为参数之一，由函数填充它。从技术角度讲，这也是一种修改函数。 

2. 纯函数：该函数的返回结果只取决于参数值，并且没有像修改参数、输出一些值等副作用。

3. 纯函数不修改接受的参数值，故传引用和传值是一样的。传引用少了复制，高效，传值则隔离了环境，安全。如果某个函数，不修改其参数，可以声明一个常量引用参数，即用const修饰，这样既高效又安全。

4. 填充函数，这种函数不是在每次调用时都创建一个新对象，而是要求调用者提供一个“空对象”用以存储结果。

   填充函数的优点在于调用者可以选择重用同一个对象来重复执行一组操作，这样可以带来效率的提升，但也可能会引发小错误。

```c++
void addTimeFill (const Time& t1, const Time& t2, Time& sum) { 
    sum.hour = t1.hour + t2.hour; //sum对象由调用者提供，要进行修改，不能为const
    sum.minute = t1.minute + t2.minute;
    sum.second = t1.second + t2.second;
    if (sum.second >= 60.0) {
        sum.second -= 60.0;
        sum.minute += 1;
    }
    if (sum.minute >= 60) {
        sum.minute -= 60;
        sum.hour += 1;
    }
}
```

5. 修改函数和填充函数可以做到的事情，纯函数都可以做到，有一些函数式语言甚至只支持纯函数。纯函数的优点在于开发速度快且不易出错，但是有的时候修改函数更方便。总而言之，能用纯函数的时候尽量编写纯函数，在修改函数有着无可比拟的优势时，再使用修改函数。

6. 增量开发是一种快速建原型及迭代完善的开发方法，虽然有效，但是有时候也会带来没有必要的复杂，因为要处理很多特殊的情况，而且不可靠。另外一种方法就是高屋建瓴，对问题进行深入分析，再进行开发。

7. 有时把问题变得更难（抽象使其更具通用性，通常会增加运算）反而使其更易解决（更少特例，更少出错）。编写程序前要考虑程序的简短、易读、易调试、可靠性。

    

#### Chapter 10 向量

1. 向量的复制：向量使用一个复制构造函数进行复制，因为它将原来的向量作为参数来创建一个新的向量，这个新的向量的元素和类型都和原来的向量一致。

   ```c++
   vector<int> copy (count); //复制构造函数
   vector<int> copy = count; //用赋值操作符效果和上面的一样，且更常用
   ```

2. 随机数的使用， stdlib.h包含这个函数random()，返回一个0到RAND_MAX之间的整型数。注意伪随机和真随机，随机种子，srand()等。

   

#### Chapter 11 成员函数

1. 如果有一些函数都需要某个结构体或者变量作为参数，则可以反客为主，将这个结构体或者变量作为中心，这些函数绑定在这个变量之上，这会使得关系更加明显，抽象层次更高，复杂度控制得更好，以数据为中心封装操作。这也是成员函数的由来。

2. 成员函数：1.调用函数时，不是直接调用，而是通过对象调用它。人们通常将这种过程描述成“对一个对象执行操作”或者“给一个对象发送消息”。2.  函数在结构体定义中声明，以使结构和函数之间的关系更加明显。 

3. 要在对象上调用函数，必须将对象的信息传递给函数，但是不是作为参数，而是用this，this指代这个函数的当前对象。 this实际上是一个指向结构的**指针**，而不是结构本身。 使用*  操作符，可以把一个结构体指针转化成结构体 。

   ```c++
   struct Time {
     int hour, minute;
     double second;
   
     void Time::print ();//函数声明
   };
   
   // 函数实现
   void Time::print() {
     Time time = *this;
     cout << time.hour << ":" << time.minute << ":" << time.second << endl;
     //成员函数也支持隐式变量访问，C++知道指的是当前对象，故下面这句和上面两句是等价的。
     //cout << hour << ":" << minute << ":" << second <<endl;  
   }
   
   Time currentTime = { 9, 14, 30.0 };
   currentTime.print();
   ```

4. 构造函数：为类型创造新的对象。首先，构造函数名字和类名/结构体名相同，没有返回类型，且参数并没有改变。 其次，并不需要创建一个新的对象，也不需要返回任何东西，这两步都是自动处理的。最后，可以使用关键字this或者隐式方式来引用新对象----我们构造的那个对象。当我们给某些变量写入值而没有声明时，编译器知道我们引用的是新对象的实例变量。 

   ```c++
   Time::Time (double secs) {
       hour = int (secs / 3600.0);
       secs -= hour * 3600.0;
       minute = int (secs / 60.0);
       secs -= minue * 60.0;
       second = secs;
   }
   
   Time time (seconds);//声明了一个Time类型的变量time，并调用写的构造函数，把seconds的值作为参数传递给构造函数。系统为新对象分配空间，而构造函数初始化了它的实例变量。结果赋给了变量time。
   ```

5. 有两种方式声明和初始化，一种是使用大括号，一种是使用括号，即使用构造函数。两种都可以，但是在一个程序中不能两种都使用。如果为结构体定义了一个构造函数，那么需要使用构造函数来初始化该类型的所有新的结构。不再允许使用花括号的那种语法。

   幸运的是，**使用重载函数来重载构造函数是合法的**。换句话说，可以存在多个构造函数具有相同的"名字"，只要它们的参数不同就行。当我们初始化一个新的对象时，编译器会尝试找到具有合适参数的构造函数。

6. ```c++
   Time currentTime = { 9, 14, 30.0 };//列表初始化
   Time time (seconds);//直接初始化，调用构造函数
   ```

7. 默认初始化、值初始化、直接初始化、拷贝初始化、列表初始化。

   **默认初始化**： 定义变量时没有指定初值时进行的初始化操作 ，也叫隐式初始化。对于内置类型变量，在语句外，即{}外，初始化为0，在语句内，即{}内，拥有未定义的值。对于类类型变量，会执行默认构造函数，如无默认构造函数，则会报错。

   **值初始化**:只使用了初始化器（即使用了圆括号或花括号）但却没有提供初始值的情况，如int *p=new int();vector<string> vec(10); 

   **直接初始化**：采用小括号方式进行变量初始化(小括号里一定要有初始值)。

   **拷贝初始化**：采用等号进行初始化的方式，注意这不是变量赋值，这和先定义再赋值是不一样的。

   **列表初始化**：采用花括号进行初始化操作，能用直接初始化和拷贝初始化的地方都能用列表初始化 。

   ```c++
   //默认初始化 Default Initialization 
   int a; 
   Sales_data myData;
   int *p=new int;
   
   //值初始化，比默认初始化多个括号，比直接初始化少个值 
   int *p=new int();
   
   //直接初始化，使用小括号，小括号里面有初始值，direct initialization 
   int a(12);
   Sales_data myData(para);
   vector<int> ivec(ivec2);
   string s("123456");
   
   //拷贝初始化,使用等号，copy initialization
   int a=12;
   string s=string("123456");
   
   //列表初始化，使用花括号，List Initialization
   int a{12};
   string s{"123"};
   vector<int> vec{1,2,3};
   
   ```

8. 在结构体中声明函数，稍后再定义函数，看起来比较麻烦，因为修改的话要修改两处地方，但是这是有理由的。一般来说，我们将结构体定义和函数分离到两个文件中：头文件包含着结构体定义，而实现文件包含着函数。 头文件通常和实现文件同名，但后缀是.h而不是.cpp。  头文件中的声明和cpp文件中定义并非要顺序一致。cpp文件中需使用include将头文件包含。这样分割对于小的程序来说没有必要，但对于大程序是有用的：

   1.重用，其他文件只需要include就行

   2.管理交互，系统变大会使得组件之间的交互数量快速增加，难以管理，分离的话，可以最小化这些交互。

   3.独立编译，单独的文件可以独立编译，之后链接到一个程序中去。独立编译能节省很多时间。

#### Chapter 12 对象

1.  组合是指以各种不同的排列方式组织语言特性的能力，优先使用对象组合而不是继承。
2.  递归程序中两个常见错误，一个是忘记了包含基本条件，另一个是递归调用永远取不到基本条件。每个错误都会导致无穷递归。
3.  抽象，指的是在更高层次上描述函数，并非程序代码的字面意思。  这种思考方式—即程序带上了超出编码字面意思之外的意义—是计算机科学的一个中心思想，因为抽象控制了复杂度。 抽象的一个更一般的定义是“为了抓住重要行为且抑制不必要的细节，使用简单的描述建模复杂系统的过程”。 
4.  抽象参数（abstract parameter）： 看以看作一个单一参数的几个参数的集合。 



#### Chapter 13 对象II

1. 枚举类型，switch语句，

2. 多个构造函数设计

3. 洗牌算法伪代码

   ```C++
   for (int i=0; i<cards.length(); i++) {
   // 在i和cards.length()之间选择一个随机数
   // 将第i张牌和随机选择的纸牌交换
   }
   ```

4.  伪代码有助于**辅助函数**的设计，使用伪代码指出需要什么辅助函数的过程称为**自上而下**的设计 。



#### Chapter 14 类

1.  封装是指将一系列指令放在一个函数体内部的处理过程。而这样的做法则是为了将函数的接口与它的实现分离（函数接口指如何使用这个函数，函数实现则指如何去实现这个函数及实现具体做了些什么）。
2. 基于函数的封装为**功能封装**，基于类或结构体的封装则为**数据封装**。 3
3. 数据封装是基于这样的理念提出的：每一个结构的定义应当包括应用于本结构的函数集以及阻止对内部的无限制访问。即以数据为中心，将它上面的操作集成，隐藏内部细节，作为一个整体对外提供服务。
4.  在C++中确保数据封装的通常办法是通过禁止客户程序访问对象的变量来实现的。在结构定义时使用关键字private进行保护。一般函数是公共的，这就意味着他们可以被用户程序调用。而变量是私有的，只能被成员函数进行读写。  但通过访问函数（以get和set开头的函数）可以实现用户程序对私有变量的读写。 
5. 使用get/set之类的访问函数优点： 一是容易控制哪个操作用户可以实施于哪个变量上， 二是可以改变数据内部表达形式而不必更改用户的程序。 
6.  使用struct和class，**唯一的区别就是默认的访问权限不同**。 本质上来说是同一个东西。但是有一点，词意上的区分，一般使用结构体就只含数据成员和构造函数、析构函数，尽可能保持简单。而使用类则包含更多的非构造、析构成员函数，概念更大，用来描述普遍意义上的对象类型。
7. 写程序时为了尽可能robust，应当将对接收的参数所做的隐含假设明确化。即写出函数的使用先决条件，有的时候可以添加后置条件，即函数执行后必定为真的事情。这种注释有助于阅读代码和调试。一般用assert来检查先决条件。





#### Chapter 15 文件输入/输出

1.  **流**是一个抽象对象，它表示从源（如键盘或文件）到目标（如屏幕或文件）的数据流动。 常用的有cin和cout，其类型分别是istream和ostream。cin代表从键盘到程序的数据流。每次程序使用>>操作符或getline函数时会将数据从输入流中取走。  类似的，程序在ostream上使用<<操作符时，它将数据添加到输出流。 
2. 输入输出，文件增删查改，输入解析。

